{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"prefect-snowflake","text":"<p>              </p>"},{"location":"#welcome","title":"Welcome!","text":"<p>Prefect integrations for interacting with prefect-snowflake.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#python-setup","title":"Python setup","text":"<p>Requires an installation of Python 3.7+.</p> <p>We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv.</p> <p>These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install <code>prefect-snowflake</code> with <code>pip</code>:</p> <pre><code>pip install prefect-snowflake\n</code></pre> <p>A list of available blocks in <code>prefect-snowflake</code> and their setup instructions can be found here.</p>"},{"location":"#query-from-table","title":"Query from table","text":"<pre><code>from prefect import flow\nfrom prefect_snowflake.credentials import SnowflakeCredentials\nfrom prefect_snowflake.database import SnowflakeConnector, snowflake_query\n\n\n@flow\ndef snowflake_query_flow():\n    snowflake_credentials = SnowflakeCredentials(\n        account=\"account\",\n        user=\"user\",\n        password=\"password\",\n    )\n    snowflake_connector = SnowflakeConnector(\n        database=\"database\",\n        warehouse=\"warehouse\",\n        schema=\"schema\",\n        credentials=snowflake_credentials\n    )\n    result = snowflake_query(\n        \"SELECT * FROM table WHERE id=%{id_param}s LIMIT 8;\",\n        snowflake_connector,\n        params={\"id_param\": 1}\n    )\n    return result\n\nsnowflake_query_flow()\n</code></pre>"},{"location":"#write-pandas-to-table-using-block-attributes","title":"Write pandas to table using block attributes","text":"<pre><code>import pandas as pd\nfrom prefect import flow\nfrom prefect_snowflake.credentials import SnowflakeCredentials\nfrom prefect_snowflake.database import SnowflakeConnector, snowflake_query\nfrom snowflake.connector.pandas_tools import write_pandas\n\n@flow\ndef snowflake_write_pandas_flow():\n    snowflake_connector = SnowflakeConnector.load(\"my-block\")\n    with snowflake_connector.get_connection() as conn:\n        table_name = \"TABLE_NAME\"\n        ddl = \"NAME STRING, NUMBER INT\"\n        statement = f'CREATE TABLE IF NOT EXISTS {table_name} ({ddl})'\n        with conn.cursor() as cur:\n            cur.execute(statement)\n\n        # case sensitivity matters here!\n        df = pd.DataFrame([('Marvin', 42), ('Ford', 88)], columns=['NAME', 'NUMBER'])\n        success, num_chunks, num_rows, _ = write_pandas(\n            conn=conn,\n            df=df,\n            table_name=table_name,\n            database=snowflake_connector.database,\n            schema=snowflake_connector.schema_  # note the \"_\" suffix\n        )\n</code></pre>"},{"location":"#execute-get-and-put-statements","title":"Execute <code>get</code> and <code>put</code> statements","text":"<p>To execute <code>get</code> and <code>put</code> statements, use <code>snowflake_query_sync</code>.</p> <pre><code>from prefect import flow\nfrom prefect_snowflake.database import SnowflakeConnector, snowflake_query_sync\n\n@flow\ndef snowflake_put_file_to_snowflake_stage():\n    snowflake_connector = SnowflakeConnector.load(\"my-block\")\n\n    snowflake_query_sync(\n        f\"put file:///myfolder/myfile @mystage/mystagepath\",\n        snowflake_connector=snowflake_connector\n    )\n</code></pre>"},{"location":"#use-with_options-to-customize-options-on-any-existing-task-or-flow","title":"Use <code>with_options</code> to customize options on any existing task or flow:","text":"<pre><code>from prefect import flow\nfrom prefect_snowflake.database import SnowflakeConnector, snowflake_query_sync\n\ncustom_snowflake_query_sync = snowflake_query_sync.with_options(\n    name=\"My custom task name\",\n    retries=2,\n    retry_delay_seconds=10,\n)\n\n@flow\ndef example_with_options_flow():\nsnowflake_connector = SnowflakeConnector.load(\"my-block\")\n\ncustom_snowflake_query_sync(\n    f\"put file:///myfolder/myfile @mystage/mystagepath\",\n    snowflake_connector=snowflake_connector\n)\n\nexample_with_options_flow()\n</code></pre> <p>For more tips on how to use tasks and flows in a Collection, check out Using Collections!</p>"},{"location":"#blocks-catalog","title":"Blocks Catalog","text":"<p>Below is a list of Blocks available for registration in <code>prefect-snowflake</code>.</p> <p>To register blocks in this module to view and edit them on Prefect Cloud: <pre><code>prefect block register -m prefect_snowflake\n</code></pre> Note, to use the <code>load</code> method on Blocks, you must already have a block document saved through code or saved through the UI.</p>"},{"location":"#credentials-module","title":"Credentials Module","text":"<p>SnowflakeCredentials</p> <p>To load the SnowflakeCredentials: <pre><code>from prefect import flow\nfrom prefect_snowflake.credentials import SnowflakeCredentials\n\n@flow\ndef my_flow():\n    my_block = SnowflakeCredentials.load(\"MY_BLOCK_NAME\")\n\nmy_flow()\n</code></pre></p>"},{"location":"#database-module","title":"Database Module","text":"<p>SnowflakeConnector</p> <p>To load the SnowflakeConnector: <pre><code>from prefect import flow\nfrom prefect_snowflake.database import SnowflakeConnector\n\n@flow\ndef my_flow():\n    my_block = SnowflakeConnector.load(\"MY_BLOCK_NAME\")\n\nmy_flow()\n</code></pre></p>"},{"location":"#resources","title":"Resources","text":"<p>If you encounter any bugs while using <code>prefect-snowflake</code>, feel free to open an issue in the prefect-snowflake repository.</p> <p>If you have any questions or issues while using <code>prefect-snowflake</code>, you can find help in either the Prefect Discourse forum or the Prefect Slack community.</p> <p>Feel free to star or watch <code>prefect-snowflake</code> for updates too!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you'd like to help contribute to fix an issue or add a feature to <code>prefect-snowflake</code>, please propose changes through a pull request from a fork of the repository.</p> <p>Here are the steps: 1. Fork the repository 2. Clone the forked repository 3. Install the repository and its dependencies: <pre><code>pip install -e \".[dev]\"\n</code></pre> 4. Make desired changes 5. Add tests 6. Insert an entry to CHANGELOG.md 7. Install <code>pre-commit</code> to perform quality checks prior to commit: <pre><code>pre-commit install\n</code></pre> 8. <code>git commit</code>, <code>git push</code>, and create a pull request</p>"},{"location":"credentials/","title":"Credentials","text":""},{"location":"credentials/#prefect_snowflake.credentials","title":"<code>prefect_snowflake.credentials</code>","text":"<p>Credentials block for authenticating with Snowflake.</p>"},{"location":"credentials/#prefect_snowflake.credentials-classes","title":"Classes","text":""},{"location":"credentials/#prefect_snowflake.credentials.InvalidPemFormat","title":"<code> InvalidPemFormat            (Exception)         </code>","text":"<p>Invalid PEM Format Certificate</p>  Source code in <code>prefect_snowflake/credentials.py</code> <pre><code>class InvalidPemFormat(Exception):\n    \"\"\"Invalid PEM Format Certificate\"\"\"\n</code></pre>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials","title":"<code> SnowflakeCredentials            (CredentialsBlock)         </code>  <code>pydantic-model</code>","text":"<p>Block used to manage authentication with Snowflake.</p> <p>Parameters:</p>    Name Type Description Default     <code>account</code> <code>str</code> <p>The snowflake account name.</p> required   <code>user</code> <code>str</code> <p>The user name used to authenticate.</p> required   <code>password</code> <code>SecretStr</code> <p>The password used to authenticate.</p> required   <code>private_key</code> <code>SecretStr</code> <p>The PEM used to authenticate.</p> required   <code>authenticator</code> <code>str</code> <p>The type of authenticator to use for initializing connection (oauth, externalbrowser, etc); refer to Snowflake documentation for details, and note that <code>externalbrowser</code> will only work in an environment where a browser is available.</p> required   <code>token</code> <code>SecretStr</code> <p>The OAuth or JWT Token to provide when authenticator is set to OAuth.</p> required   <code>endpoint</code> <code>str</code> <p>The Okta endpoint to use when authenticator is set to <code>okta_endpoint</code>, e.g. <code>https://&lt;okta_account_name&gt;.okta.com</code>.</p> required   <code>role</code> <code>str</code> <p>The name of the default role to use.</p> required   <code>autocommit</code> <code>bool</code> <p>Whether to automatically commit.</p> required    <p>Examples:</p> <p>Load stored Snowflake credentials: <pre><code>from prefect_snowflake import SnowflakeCredentials\n\nsnowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\")\n</code></pre></p>  Source code in <code>prefect_snowflake/credentials.py</code> <pre><code>class SnowflakeCredentials(CredentialsBlock):\n    \"\"\"\n    Block used to manage authentication with Snowflake.\n\n    Args:\n        account (str): The snowflake account name.\n        user (str): The user name used to authenticate.\n        password (SecretStr): The password used to authenticate.\n        private_key (SecretStr): The PEM used to authenticate.\n        authenticator (str): The type of authenticator to use for initializing\n            connection (oauth, externalbrowser, etc); refer to\n            [Snowflake documentation](https://docs.snowflake.com/en/user-guide/python-connector-api.html#connect)\n            for details, and note that `externalbrowser` will only\n            work in an environment where a browser is available.\n        token (SecretStr): The OAuth or JWT Token to provide when\n            authenticator is set to OAuth.\n        endpoint (str): The Okta endpoint to use when authenticator is\n            set to `okta_endpoint`, e.g. `https://&lt;okta_account_name&gt;.okta.com`.\n        role (str): The name of the default role to use.\n        autocommit (bool): Whether to automatically commit.\n\n    Example:\n        Load stored Snowflake credentials:\n        ```python\n        from prefect_snowflake import SnowflakeCredentials\n\n        snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\")\n        ```\n    \"\"\"  # noqa E501\n\n    _block_type_name = \"Snowflake Credentials\"\n    _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/2DxzAeTM9eHLDcRQx1FR34/f858a501cdff918d398b39365ec2150f/snowflake.png?h=250\"  # noqa\n\n    account: str = Field(\n        ..., description=\"The snowflake account name.\", example=\"nh12345.us-east-2.aws\"\n    )\n    user: str = Field(..., description=\"The user name used to authenticate.\")\n    password: Optional[SecretStr] = Field(\n        default=None, description=\"The password used to authenticate.\"\n    )\n    private_key: Optional[SecretBytes] = Field(\n        default=None, description=\"The PEM used to authenticate.\"\n    )\n    private_key_path: Optional[Path] = Field(\n        default=None, description=\"The path to the private key.\"\n    )\n    private_key_passphrase: Optional[SecretStr] = Field(\n        default=None, description=\"The password to use for the private key.\"\n    )\n    authenticator: Literal[\n        \"snowflake\",\n        \"snowflake_jwt\",\n        \"externalbrowser\",\n        \"okta_endpoint\",\n        \"oauth\",\n        \"username_password_mfa\",\n    ] = Field(  # noqa\n        default=\"snowflake\",\n        description=(\"The type of authenticator to use for initializing connection.\"),\n    )\n    token: Optional[SecretStr] = Field(\n        default=None,\n        description=(\n            \"The OAuth or JWT Token to provide when authenticator is set to `oauth`.\"\n        ),\n    )\n    endpoint: Optional[str] = Field(\n        default=None,\n        description=(\n            \"The Okta endpoint to use when authenticator is set to `okta_endpoint`.\"\n        ),\n    )\n    role: Optional[str] = Field(\n        default=None, description=\"The name of the default role to use.\"\n    )\n    autocommit: Optional[bool] = Field(\n        default=None, description=\"Whether to automatically commit.\"\n    )\n\n    @root_validator(pre=True)\n    def _validate_auth_kwargs(cls, values):\n        \"\"\"\n        Ensure an authorization value has been provided by the user.\n        \"\"\"\n        auth_params = (\n            \"password\",\n            \"private_key\",\n            \"private_key_path\",\n            \"authenticator\",\n            \"token\",\n        )\n        if not any(values.get(param) for param in auth_params):\n            auth_str = \", \".join(auth_params)\n            raise ValueError(\n                f\"One of the authentication keys must be provided: {auth_str}\\n\"\n            )\n        elif \"private_key\" in values and \"private_key_path\" in values:\n            raise ValueError(\n                \"Do not provide both private_key and private_key_path; select one.\"\n            )\n        elif \"password\" in values and \"private_key_passphrase\" in values:\n            raise ValueError(\n                \"Do not provide both password and private_key_passphrase; \"\n                \"specify private_key_passphrase only instead.\"\n            )\n        return values\n\n    @root_validator(pre=True)\n    def _validate_token_kwargs(cls, values):\n        \"\"\"\n        Ensure an authorization value has been provided by the user.\n        \"\"\"\n        authenticator = values.get(\"authenticator\")\n        token = values.get(\"token\")\n        if authenticator == \"oauth\" and not token:\n            raise ValueError(\n                \"If authenticator is set to `oauth`, `token` must be provided\"\n            )\n        return values\n\n    @root_validator(pre=True)\n    def _validate_okta_kwargs(cls, values):\n        \"\"\"\n        Ensure an authorization value has been provided by the user.\n        \"\"\"\n        authenticator = values.get(\"authenticator\")\n\n        # did not want to make a breaking change so we will allow both\n        # see https://github.com/PrefectHQ/prefect-snowflake/issues/44\n        if \"okta_endpoint\" in values.keys():\n            warnings.warn(\n                \"Please specify `endpoint` instead of `okta_endpoint`; \"\n                \"`okta_endpoint` will be removed March 31, 2023.\",\n                DeprecationWarning,\n            )\n            # remove okta endpoint from fields\n            okta_endpoint = values.pop(\"okta_endpoint\")\n            if \"endpoint\" not in values.keys():\n                values[\"endpoint\"] = okta_endpoint\n\n        endpoint = values.get(\"endpoint\")\n        if authenticator == \"okta_endpoint\" and not endpoint:\n            raise ValueError(\n                \"If authenticator is set to `okta_endpoint`, \"\n                \"`endpoint` must be provided\"\n            )\n        return values\n\n    @validator(\"private_key\")\n    def _validate_private_key(cls, private_key):\n        \"\"\"\n        Ensure a private_key looks like a PEM format certificate.\n        \"\"\"\n\n        if private_key is None:\n            return None\n\n        assert isinstance(private_key, SecretBytes)\n\n        pk = cls._decode_secret(private_key)\n\n        return None if pk is None else SecretBytes(cls._compose_pem(pk))\n\n    def resolve_private_key(self) -&gt; Optional[bytes]:\n        \"\"\"\n        Converts a PEM encoded private key into a DER binary key.\n\n        Returns:\n            DER encoded key if private_key has been provided otherwise returns None.\n\n        Raises:\n            InvalidPemFormat: If private key is not in PEM format.\n        \"\"\"\n\n        private_key = self._decode_secret(self.private_key)\n\n        if private_key is None:\n            return None\n\n        if self.private_key_passphrase is not None:\n            password = self._decode_secret(self.private_key_passphrase)\n        elif self.password is not None:\n            warnings.warn(\n                \"Using the password field for private_key is deprecated \"\n                \"and will not work after March 31, 2023; please use \"\n                \"private_key_passphrase instead\",\n                DeprecationWarning,\n            )\n            password = self._decode_secret(self.password)\n        else:\n            password = None\n\n        return load_pem_private_key(\n            data=private_key,\n            password=password,\n            backend=default_backend(),\n        ).private_bytes(\n            encoding=Encoding.DER,\n            format=PrivateFormat.PKCS8,\n            encryption_algorithm=NoEncryption(),\n        )\n\n    @staticmethod\n    def _decode_secret(secret: Union[SecretStr, SecretBytes]) -&gt; Optional[bytes]:\n        \"\"\"\n        Decode the provided secret into bytes. If the secret is not a\n        string or bytes, or it is whitespace, then return None.\n\n        Args:\n            secret: The value to decode.\n\n        Returns:\n            The decoded secret as bytes.\n\n        \"\"\"\n        if isinstance(secret, (SecretBytes, SecretStr)):\n            secret = secret.get_secret_value()\n\n        if not isinstance(secret, (bytes, str)) or len(secret) == 0 or secret.isspace():\n            return None\n\n        return secret if isinstance(secret, bytes) else secret.encode()\n\n    @staticmethod\n    def _compose_pem(private_key: bytes) -&gt; bytes:\n        \"\"\"Validate structure of PEM certificate.\n\n        The original key passed from Prefect is sometimes malformed.\n        This function recomposes the key into a valid key that will\n        pass the serialization step when resolving the key to a DER.\n\n        Args:\n            private_key: A valid PEM format byte encoded string.\n\n        Returns:\n            byte encoded certificate.\n\n        Raises:\n            InvalidPemFormat: if private key is an invalid format.\n        \"\"\"\n        pem_parts = re.match(_SIMPLE_PEM_CERTIFICATE_REGEX, private_key.decode())\n        if pem_parts is None:\n            raise InvalidPemFormat()\n\n        body = \"\\n\".join(re.split(r\"\\s+\", pem_parts[2].strip()))\n        # reassemble header+body+footer\n        return f\"{pem_parts[1]}\\n{body}\\n{pem_parts[3]}\".encode()\n\n    def get_client(\n        self, **connect_kwargs: Dict[str, Any]\n    ) -&gt; snowflake.connector.SnowflakeConnection:\n        \"\"\"\n        Returns an authenticated connection that can be used to query\n        Snowflake databases.\n\n        Any additional arguments passed to this method will be used to configure\n        the SnowflakeConnection. For available parameters, please refer to the\n        [Snowflake Python connector documentation](https://docs.snowflake.com/en/user-guide/python-connector-api.html#connect).\n\n        Args:\n            **connect_kwargs: Additional arguments to pass to\n                `snowflake.connector.connect`.\n\n        Returns:\n            An authenticated Snowflake connection.\n\n        Example:\n            Get Snowflake connection with only block configuration:\n            ```python\n            from prefect_snowflake import SnowflakeCredentials\n\n            snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\")\n\n            connection = snowflake_credentials_block.get_client()\n            ```\n\n            Get Snowflake connector scoped to a specified database:\n            ```python\n            from prefect_snowflake import SnowflakeCredentials\n\n            snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\")\n\n            connection = snowflake_credentials_block.get_client(database=\"my_database\")\n            ```\n        \"\"\"  # noqa\n        connect_params = {\n            **connect_kwargs,\n            # required to track task's usage in the Snowflake Partner Network Portal\n            \"application\": \"Prefect_Snowflake_Collection\",\n            **self.dict(exclude_unset=True, exclude={\"block_type_slug\"}),\n        }\n\n        for key, value in connect_params.items():\n            if isinstance(value, SecretField):\n                connect_params[key] = connect_params[key].get_secret_value()\n\n        # set authenticator to the actual okta_endpoint\n        if connect_params.get(\"authenticator\") == \"okta_endpoint\":\n            endpoint = connect_params.pop(\"endpoint\", None) or connect_params.pop(\n                \"okta_endpoint\", None\n            )  # okta_endpoint is deprecated\n            connect_params[\"authenticator\"] = endpoint\n\n        private_der_key = self.resolve_private_key()\n        if private_der_key is not None:\n            connect_params[\"private_key\"] = private_der_key\n            connect_params.pop(\"password\", None)\n\n        return snowflake.connector.connect(**connect_params)\n</code></pre>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials-attributes","title":"Attributes","text":""},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.account","title":"<code>account: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The snowflake account name.</p>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.authenticator","title":"<code>authenticator: Literal['snowflake', 'snowflake_jwt', 'externalbrowser', 'okta_endpoint', 'oauth', 'username_password_mfa']</code>  <code>pydantic-field</code>","text":"<p>The type of authenticator to use for initializing connection.</p>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.autocommit","title":"<code>autocommit: bool</code>  <code>pydantic-field</code>","text":"<p>Whether to automatically commit.</p>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.endpoint","title":"<code>endpoint: str</code>  <code>pydantic-field</code>","text":"<p>The Okta endpoint to use when authenticator is set to <code>okta_endpoint</code>.</p>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.password","title":"<code>password: SecretStr</code>  <code>pydantic-field</code>","text":"<p>The password used to authenticate.</p>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.private_key","title":"<code>private_key: SecretBytes</code>  <code>pydantic-field</code>","text":"<p>The PEM used to authenticate.</p>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.private_key_passphrase","title":"<code>private_key_passphrase: SecretStr</code>  <code>pydantic-field</code>","text":"<p>The password to use for the private key.</p>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.private_key_path","title":"<code>private_key_path: Path</code>  <code>pydantic-field</code>","text":"<p>The path to the private key.</p>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.role","title":"<code>role: str</code>  <code>pydantic-field</code>","text":"<p>The name of the default role to use.</p>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.token","title":"<code>token: SecretStr</code>  <code>pydantic-field</code>","text":"<p>The OAuth or JWT Token to provide when authenticator is set to <code>oauth</code>.</p>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.user","title":"<code>user: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The user name used to authenticate.</p>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials-methods","title":"Methods","text":""},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.__json_encoder__","title":"<code>__json_encoder__</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.get_client","title":"<code>get_client</code>","text":"<p>Returns an authenticated connection that can be used to query Snowflake databases.</p> <p>Any additional arguments passed to this method will be used to configure the SnowflakeConnection. For available parameters, please refer to the Snowflake Python connector documentation.</p> <p>Parameters:</p>    Name Type Description Default     <code>**connect_kwargs</code> <code>Dict[str, Any]</code> <p>Additional arguments to pass to <code>snowflake.connector.connect</code>.</p> <code>{}</code>    <p>Returns:</p>    Type Description     <code>SnowflakeConnection</code> <p>An authenticated Snowflake connection.</p>    <p>Examples:</p> <p>Get Snowflake connection with only block configuration: <pre><code>from prefect_snowflake import SnowflakeCredentials\n\nsnowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\")\n\nconnection = snowflake_credentials_block.get_client()\n</code></pre></p> <p>Get Snowflake connector scoped to a specified database: <pre><code>from prefect_snowflake import SnowflakeCredentials\n\nsnowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\")\n\nconnection = snowflake_credentials_block.get_client(database=\"my_database\")\n</code></pre></p>  Source code in <code>prefect_snowflake/credentials.py</code> <pre><code>def get_client(\n    self, **connect_kwargs: Dict[str, Any]\n) -&gt; snowflake.connector.SnowflakeConnection:\n    \"\"\"\n    Returns an authenticated connection that can be used to query\n    Snowflake databases.\n\n    Any additional arguments passed to this method will be used to configure\n    the SnowflakeConnection. For available parameters, please refer to the\n    [Snowflake Python connector documentation](https://docs.snowflake.com/en/user-guide/python-connector-api.html#connect).\n\n    Args:\n        **connect_kwargs: Additional arguments to pass to\n            `snowflake.connector.connect`.\n\n    Returns:\n        An authenticated Snowflake connection.\n\n    Example:\n        Get Snowflake connection with only block configuration:\n        ```python\n        from prefect_snowflake import SnowflakeCredentials\n\n        snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\")\n\n        connection = snowflake_credentials_block.get_client()\n        ```\n\n        Get Snowflake connector scoped to a specified database:\n        ```python\n        from prefect_snowflake import SnowflakeCredentials\n\n        snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\")\n\n        connection = snowflake_credentials_block.get_client(database=\"my_database\")\n        ```\n    \"\"\"  # noqa\n    connect_params = {\n        **connect_kwargs,\n        # required to track task's usage in the Snowflake Partner Network Portal\n        \"application\": \"Prefect_Snowflake_Collection\",\n        **self.dict(exclude_unset=True, exclude={\"block_type_slug\"}),\n    }\n\n    for key, value in connect_params.items():\n        if isinstance(value, SecretField):\n            connect_params[key] = connect_params[key].get_secret_value()\n\n    # set authenticator to the actual okta_endpoint\n    if connect_params.get(\"authenticator\") == \"okta_endpoint\":\n        endpoint = connect_params.pop(\"endpoint\", None) or connect_params.pop(\n            \"okta_endpoint\", None\n        )  # okta_endpoint is deprecated\n        connect_params[\"authenticator\"] = endpoint\n\n    private_der_key = self.resolve_private_key()\n    if private_der_key is not None:\n        connect_params[\"private_key\"] = private_der_key\n        connect_params.pop(\"password\", None)\n\n    return snowflake.connector.connect(**connect_params)\n</code></pre>"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.resolve_private_key","title":"<code>resolve_private_key</code>","text":"<p>Converts a PEM encoded private key into a DER binary key.</p> <p>Returns:</p>    Type Description     <code>Optional[bytes]</code> <p>DER encoded key if private_key has been provided otherwise returns None.</p>    <p>Exceptions:</p>    Type Description     <code>InvalidPemFormat</code> <p>If private key is not in PEM format.</p>     Source code in <code>prefect_snowflake/credentials.py</code> <pre><code>def resolve_private_key(self) -&gt; Optional[bytes]:\n    \"\"\"\n    Converts a PEM encoded private key into a DER binary key.\n\n    Returns:\n        DER encoded key if private_key has been provided otherwise returns None.\n\n    Raises:\n        InvalidPemFormat: If private key is not in PEM format.\n    \"\"\"\n\n    private_key = self._decode_secret(self.private_key)\n\n    if private_key is None:\n        return None\n\n    if self.private_key_passphrase is not None:\n        password = self._decode_secret(self.private_key_passphrase)\n    elif self.password is not None:\n        warnings.warn(\n            \"Using the password field for private_key is deprecated \"\n            \"and will not work after March 31, 2023; please use \"\n            \"private_key_passphrase instead\",\n            DeprecationWarning,\n        )\n        password = self._decode_secret(self.password)\n    else:\n        password = None\n\n    return load_pem_private_key(\n        data=private_key,\n        password=password,\n        backend=default_backend(),\n    ).private_bytes(\n        encoding=Encoding.DER,\n        format=PrivateFormat.PKCS8,\n        encryption_algorithm=NoEncryption(),\n    )\n</code></pre>"},{"location":"database/","title":"Database","text":""},{"location":"database/#prefect_snowflake.database","title":"<code>prefect_snowflake.database</code>","text":"<p>Module for querying against Snowflake databases.</p>"},{"location":"database/#prefect_snowflake.database-classes","title":"Classes","text":""},{"location":"database/#prefect_snowflake.database.SnowflakeConnector","title":"<code> SnowflakeConnector            (DatabaseBlock)         </code>  <code>pydantic-model</code>","text":"<p>Block used to manage connections with Snowflake.</p> <p>Upon instantiating, a connection is created and maintained for the life of the object until the close method is called.</p> <p>It is recommended to use this block as a context manager, which will automatically close the engine and its connections when the context is exited.</p> <p>It is also recommended that this block is loaded and consumed within a single task or flow because if the block is passed across separate tasks and flows, the state of the block's connection and cursor will be lost.</p> <p>Parameters:</p>    Name Type Description Default     <code>credentials</code>  <p>The credentials to authenticate with Snowflake.</p> required   <code>database</code>  <p>The name of the default database to use.</p> required   <code>warehouse</code>  <p>The name of the default warehouse to use.</p> required   <code>schema</code>  <p>The name of the default schema to use; this attribute is accessible through <code>SnowflakeConnector(...).schema_</code>.</p> required   <code>fetch_size</code>  <p>The number of rows to fetch at a time.</p> required   <code>poll_frequency_s</code>  <p>The number of seconds before checking query.</p> required    <p>Examples:</p> <p>Load stored Snowflake connector as a context manager: <pre><code>from prefect_snowflake.database import SnowflakeConnector\n\nsnowflake_connector = SnowflakeConnector.load(\"BLOCK_NAME\"):\n</code></pre></p> <p>Insert data into database and fetch results. <pre><code>from prefect_snowflake.database import SnowflakeConnector\n\nwith SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\n        \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n    )\n    conn.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n        seq_of_parameters=[\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n    results = conn.fetch_all(\n        \"SELECT * FROM customers WHERE address = %(address)s\",\n        parameters={\"address\": \"Space\"}\n    )\n    print(results)\n</code></pre></p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>class SnowflakeConnector(DatabaseBlock):\n\n    \"\"\"\n    Block used to manage connections with Snowflake.\n\n    Upon instantiating, a connection is created and maintained for the life of\n    the object until the close method is called.\n\n    It is recommended to use this block as a context manager, which will automatically\n    close the engine and its connections when the context is exited.\n\n    It is also recommended that this block is loaded and consumed within a single task\n    or flow because if the block is passed across separate tasks and flows,\n    the state of the block's connection and cursor will be lost.\n\n    Args:\n        credentials: The credentials to authenticate with Snowflake.\n        database: The name of the default database to use.\n        warehouse: The name of the default warehouse to use.\n        schema: The name of the default schema to use;\n            this attribute is accessible through `SnowflakeConnector(...).schema_`.\n        fetch_size: The number of rows to fetch at a time.\n        poll_frequency_s: The number of seconds before checking query.\n\n    Examples:\n        Load stored Snowflake connector as a context manager:\n        ```python\n        from prefect_snowflake.database import SnowflakeConnector\n\n        snowflake_connector = SnowflakeConnector.load(\"BLOCK_NAME\"):\n        ```\n\n        Insert data into database and fetch results.\n        ```python\n        from prefect_snowflake.database import SnowflakeConnector\n\n        with SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\n                \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n            )\n            conn.execute_many(\n                \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n                seq_of_parameters=[\n                    {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Unknown\", \"address\": \"Space\"},\n                    {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                ],\n            )\n            results = conn.fetch_all(\n                \"SELECT * FROM customers WHERE address = %(address)s\",\n                parameters={\"address\": \"Space\"}\n            )\n            print(results)\n        ```\n    \"\"\"  # noqa\n\n    _block_type_name = \"Snowflake Connector\"\n    _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/2DxzAeTM9eHLDcRQx1FR34/f858a501cdff918d398b39365ec2150f/snowflake.png?h=250\"  # noqa\n    _description = \"Perform data operations against a Snowflake database.\"\n\n    credentials: SnowflakeCredentials = Field(\n        default=..., description=\"The credentials to authenticate with Snowflake.\"\n    )\n    database: str = Field(\n        default=..., description=\"The name of the default database to use.\"\n    )\n    warehouse: str = Field(\n        default=..., description=\"The name of the default warehouse to use.\"\n    )\n    schema_: str = Field(\n        default=...,\n        alias=\"schema\",\n        description=\"The name of the default schema to use.\",\n    )\n    fetch_size: int = Field(\n        default=1, description=\"The default number of rows to fetch at a time.\"\n    )\n    poll_frequency_s: int = Field(\n        default=1,\n        title=\"Poll Frequency [seconds]\",\n        description=(\n            \"The number of seconds between checking query \"\n            \"status for long running queries.\"\n        ),\n    )\n\n    _connection: Optional[SnowflakeConnection] = None\n    _unique_cursors: Dict[str, SnowflakeCursor] = None\n\n    def get_connection(self, **connect_kwargs: Dict[str, Any]) -&gt; SnowflakeConnection:\n        \"\"\"\n        Returns an authenticated connection that can be\n        used to query from Snowflake databases.\n\n        Args:\n            **connect_kwargs: Additional arguments to pass to\n                `snowflake.connector.connect`.\n\n        Returns:\n            The authenticated SnowflakeConnection.\n\n        Examples:\n            ```python\n            from prefect_snowflake.credentials import SnowflakeCredentials\n            from prefect_snowflake.database import SnowflakeConnector\n\n            snowflake_credentials = SnowflakeCredentials(\n                account=\"account\",\n                user=\"user\",\n                password=\"password\",\n            )\n            snowflake_connector = SnowflakeConnector(\n                database=\"database\",\n                warehouse=\"warehouse\",\n                schema=\"schema\",\n                credentials=snowflake_credentials\n            )\n            with snowflake_connector.get_connection() as connection:\n                ...\n            ```\n        \"\"\"\n        if self._connection is not None:\n            return self._connection\n\n        connect_params = {\n            \"database\": self.database,\n            \"warehouse\": self.warehouse,\n            \"schema\": self.schema_,\n        }\n        connection = self.credentials.get_client(**connect_kwargs, **connect_params)\n        self._connection = connection\n        self.logger.info(\"Started a new connection to Snowflake.\")\n        return connection\n\n    def _start_connection(self):\n        \"\"\"\n        Starts Snowflake database connection.\n        \"\"\"\n        self.get_connection()\n        if self._unique_cursors is None:\n            self._unique_cursors = {}\n\n    def _get_cursor(self, inputs: Dict[str, Any]) -&gt; Tuple[bool, SnowflakeCursor]:\n        \"\"\"\n        Get a Snowflake cursor.\n\n        Args:\n            inputs: The inputs to generate a unique hash, used to decide\n                whether a new cursor should be used.\n\n        Returns:\n            Whether a cursor is new and a Snowflake cursor.\n        \"\"\"\n        self._start_connection()\n\n        input_hash = hash_objects(inputs)\n        if input_hash is None:\n            raise RuntimeError(\n                \"We were not able to hash your inputs, \"\n                \"which resulted in an unexpected data return; \"\n                \"please open an issue with a reproducible example.\"\n            )\n        if input_hash not in self._unique_cursors.keys():\n            new_cursor = self._connection.cursor()\n            self._unique_cursors[input_hash] = new_cursor\n            return True, new_cursor\n        else:\n            existing_cursor = self._unique_cursors[input_hash]\n            return False, existing_cursor\n\n    async def _execute_async(self, cursor: SnowflakeCursor, inputs: Dict[str, Any]):\n        \"\"\"Helper method to execute operations asynchronously.\"\"\"\n        response = await run_sync_in_worker_thread(cursor.execute_async, **inputs)\n        self.logger.info(\n            f\"Executing the operation, {inputs['command']!r}, asynchronously; \"\n            f\"polling for the result every {self.poll_frequency_s} seconds.\"\n        )\n\n        query_id = response[\"queryId\"]\n        while self._connection.is_still_running(\n            await run_sync_in_worker_thread(\n                self._connection.get_query_status_throw_if_error, query_id\n            )\n        ):\n            await asyncio.sleep(self.poll_frequency_s)\n        await run_sync_in_worker_thread(cursor.get_results_from_sfqid, query_id)\n\n    def reset_cursors(self) -&gt; None:\n        \"\"\"\n        Tries to close all opened cursors.\n\n        Examples:\n            Reset the cursors to refresh cursor position.\n            ```python\n            from prefect_snowflake.database import SnowflakeConnector\n\n            with SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\n                    \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n                )\n                conn.execute_many(\n                    \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n                    seq_of_parameters=[\n                        {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Unknown\", \"address\": \"Space\"},\n                        {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                    ],\n                )\n                print(conn.fetch_one(\"SELECT * FROM customers\"))  # Ford\n                conn.reset_cursors()\n                print(conn.fetch_one(\"SELECT * FROM customers\"))  # should be Ford again\n            ```\n        \"\"\"  # noqa\n        if not self._unique_cursors:\n            self.logger.info(\"There were no cursors to reset.\")\n            return\n\n        input_hashes = tuple(self._unique_cursors.keys())\n        for input_hash in input_hashes:\n            cursor = self._unique_cursors.pop(input_hash)\n            try:\n                cursor.close()\n            except Exception as exc:\n                self.logger.warning(\n                    f\"Failed to close cursor for input hash {input_hash!r}: {exc}\"\n                )\n        self.logger.info(\"Successfully reset the cursors.\")\n\n    @sync_compatible\n    async def fetch_one(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = None,\n        **execute_kwargs: Dict[str, Any],\n    ) -&gt; Tuple[Any]:\n        \"\"\"\n        Fetch a single result from the database.\n        Repeated calls using the same inputs to *any* of the fetch methods of this\n        block will skip executing the operation again, and instead,\n        return the next set of results from the previous execution,\n        until the reset_cursors method is called.\n\n        Args:\n            operation: The SQL query or other operation to be executed.\n            parameters: The parameters for the operation.\n            **execute_kwargs: Additional options to pass to `cursor.execute_async`.\n\n        Returns:\n            A tuple containing the data returned by the database,\n                where each row is a tuple and each column is a value in the tuple.\n\n        Examples:\n            Fetch one row from the database where address is Space.\n            ```python\n            from prefect_snowflake.database import SnowflakeConnector\n\n            with SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\n                    \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n                )\n                conn.execute_many(\n                    \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n                    seq_of_parameters=[\n                        {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Unknown\", \"address\": \"Space\"},\n                        {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                    ],\n                )\n                result = conn.fetch_one(\n                    \"SELECT * FROM customers WHERE address = %(address)s\",\n                    parameters={\"address\": \"Space\"}\n                )\n                print(result)\n            ```\n        \"\"\"  # noqa\n        inputs = dict(\n            command=operation,\n            params=parameters,\n            **execute_kwargs,\n        )\n        new, cursor = self._get_cursor(inputs)\n        if new:\n            await self._execute_async(cursor, inputs)\n        self.logger.debug(\"Preparing to fetch a row.\")\n        result = await run_sync_in_worker_thread(cursor.fetchone)\n        return result\n\n    @sync_compatible\n    async def fetch_many(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = None,\n        size: Optional[int] = None,\n        **execute_kwargs: Dict[str, Any],\n    ) -&gt; List[Tuple[Any]]:\n        \"\"\"\n        Fetch a limited number of results from the database.\n        Repeated calls using the same inputs to *any* of the fetch methods of this\n        block will skip executing the operation again, and instead,\n        return the next set of results from the previous execution,\n        until the reset_cursors method is called.\n\n        Args:\n            operation: The SQL query or other operation to be executed.\n            parameters: The parameters for the operation.\n            size: The number of results to return; if None or 0, uses the value of\n                `fetch_size` configured on the block.\n            **execute_kwargs: Additional options to pass to `cursor.execute_async`.\n\n        Returns:\n            A list of tuples containing the data returned by the database,\n                where each row is a tuple and each column is a value in the tuple.\n\n        Examples:\n            Repeatedly fetch two rows from the database where address is Highway 42.\n            ```python\n            from prefect_snowflake.database import SnowflakeConnector\n\n            with SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\n                    \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n                )\n                conn.execute_many(\n                    \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n                    seq_of_parameters=[\n                        {\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Unknown\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Me\", \"address\": \"Highway 42\"},\n                    ],\n                )\n                result = conn.fetch_many(\n                    \"SELECT * FROM customers WHERE address = %(address)s\",\n                    parameters={\"address\": \"Highway 42\"},\n                    size=2\n                )\n                print(result)  # Marvin, Ford\n                result = conn.fetch_many(\n                    \"SELECT * FROM customers WHERE address = %(address)s\",\n                    parameters={\"address\": \"Highway 42\"},\n                    size=2\n                )\n                print(result)  # Unknown, Me\n            ```\n        \"\"\"  # noqa\n        inputs = dict(\n            command=operation,\n            params=parameters,\n            **execute_kwargs,\n        )\n        new, cursor = self._get_cursor(inputs)\n        if new:\n            await self._execute_async(cursor, inputs)\n        size = size or self.fetch_size\n        self.logger.debug(f\"Preparing to fetch {size} rows.\")\n        result = await run_sync_in_worker_thread(cursor.fetchmany, size=size)\n        return result\n\n    @sync_compatible\n    async def fetch_all(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = None,\n        **execute_kwargs: Dict[str, Any],\n    ) -&gt; List[Tuple[Any]]:\n        \"\"\"\n        Fetch all results from the database.\n        Repeated calls using the same inputs to *any* of the fetch methods of this\n        block will skip executing the operation again, and instead,\n        return the next set of results from the previous execution,\n        until the reset_cursors method is called.\n\n        Args:\n            operation: The SQL query or other operation to be executed.\n            parameters: The parameters for the operation.\n            **execute_kwargs: Additional options to pass to `cursor.execute_async`.\n\n        Returns:\n            A list of tuples containing the data returned by the database,\n                where each row is a tuple and each column is a value in the tuple.\n\n        Examples:\n            Fetch all rows from the database where address is Highway 42.\n            ```python\n            from prefect_snowflake.database import SnowflakeConnector\n\n            with SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\n                    \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n                )\n                conn.execute_many(\n                    \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n                    seq_of_parameters=[\n                        {\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Unknown\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                    ],\n                )\n                result = conn.fetch_all(\n                    \"SELECT * FROM customers WHERE address = %(address)s\",\n                    parameters={\"address\": \"Highway 42\"},\n                )\n                print(result)  # Marvin, Ford, Unknown\n            ```\n        \"\"\"  # noqa\n        inputs = dict(\n            command=operation,\n            params=parameters,\n            **execute_kwargs,\n        )\n        new, cursor = self._get_cursor(inputs)\n        if new:\n            await self._execute_async(cursor, inputs)\n        self.logger.debug(\"Preparing to fetch all rows.\")\n        result = await run_sync_in_worker_thread(cursor.fetchall)\n        return result\n\n    @sync_compatible\n    async def execute(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = None,\n        **execute_kwargs: Dict[str, Any],\n    ) -&gt; None:\n        \"\"\"\n        Executes an operation on the database. This method is intended to be used\n        for operations that do not return data, such as INSERT, UPDATE, or DELETE.\n        Unlike the fetch methods, this method will always execute the operation\n        upon calling.\n\n        Args:\n            operation: The SQL query or other operation to be executed.\n            parameters: The parameters for the operation.\n            **execute_kwargs: Additional options to pass to `cursor.execute_async`.\n\n        Examples:\n            Create table named customers with two columns, name and address.\n            ```python\n            from prefect_snowflake.database import SnowflakeConnector\n\n            with SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\n                    \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n                )\n            ```\n        \"\"\"  # noqa\n        self._start_connection()\n\n        inputs = dict(\n            command=operation,\n            params=parameters,\n            **execute_kwargs,\n        )\n        with self._connection.cursor() as cursor:\n            await run_sync_in_worker_thread(cursor.execute, **inputs)\n        self.logger.info(f\"Executed the operation, {operation!r}.\")\n\n    @sync_compatible\n    async def execute_many(\n        self,\n        operation: str,\n        seq_of_parameters: List[Dict[str, Any]],\n    ) -&gt; None:\n        \"\"\"\n        Executes many operations on the database. This method is intended to be used\n        for operations that do not return data, such as INSERT, UPDATE, or DELETE.\n        Unlike the fetch methods, this method will always execute the operations\n        upon calling.\n\n        Args:\n            operation: The SQL query or other operation to be executed.\n            seq_of_parameters: The sequence of parameters for the operation.\n\n        Examples:\n            Create table and insert three rows into it.\n            ```python\n            from prefect_snowflake.database import SnowflakeConnector\n\n            with SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\n                    \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n                )\n                conn.execute_many(\n                    \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n                    seq_of_parameters=[\n                        {\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Unknown\", \"address\": \"Space\"},\n                    ],\n                )\n            ```\n        \"\"\"  # noqa\n        self._start_connection()\n\n        inputs = dict(\n            command=operation,\n            seqparams=seq_of_parameters,\n        )\n        with self._connection.cursor() as cursor:\n            await run_sync_in_worker_thread(cursor.executemany, **inputs)\n        self.logger.info(\n            f\"Executed {len(seq_of_parameters)} operations off {operation!r}.\"\n        )\n\n    def close(self):\n        \"\"\"\n        Closes connection and its cursors.\n        \"\"\"\n        try:\n            self.reset_cursors()\n        finally:\n            if self._connection is None:\n                self.logger.info(\"There was no connection open to be closed.\")\n                return\n            self._connection.close()\n            self._connection = None\n            self.logger.info(\"Successfully closed the Snowflake connection.\")\n\n    def __enter__(self):\n        \"\"\"\n        Start a connection upon entry.\n        \"\"\"\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"\n        Closes connection and its cursors upon exit.\n        \"\"\"\n        self.close()\n\n    def __getstate__(self):\n        \"\"\"Allows block to be pickled and dumped.\"\"\"\n        data = self.__dict__.copy()\n        data.update({k: None for k in {\"_connection\", \"_unique_cursors\"}})\n        return data\n\n    def __setstate__(self, data: dict):\n        \"\"\"Reset connection and cursors upon loading.\"\"\"\n        self.__dict__.update(data)\n        self._start_connection()\n</code></pre>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector-attributes","title":"Attributes","text":""},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.credentials","title":"<code>credentials: SnowflakeCredentials</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The credentials to authenticate with Snowflake.</p>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.database","title":"<code>database: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The name of the default database to use.</p>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.fetch_size","title":"<code>fetch_size: int</code>  <code>pydantic-field</code>","text":"<p>The default number of rows to fetch at a time.</p>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.poll_frequency_s","title":"<code>poll_frequency_s: int</code>  <code>pydantic-field</code>","text":"<p>The number of seconds between checking query status for long running queries.</p>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.schema_","title":"<code>schema_: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The name of the default schema to use.</p>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.warehouse","title":"<code>warehouse: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The name of the default warehouse to use.</p>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector-methods","title":"Methods","text":""},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.__enter__","title":"<code>__enter__</code>  <code>special</code>","text":"<p>Start a connection upon entry.</p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>def __enter__(self):\n    \"\"\"\n    Start a connection upon entry.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.__exit__","title":"<code>__exit__</code>  <code>special</code>","text":"<p>Closes connection and its cursors upon exit.</p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>def __exit__(self, *args):\n    \"\"\"\n    Closes connection and its cursors upon exit.\n    \"\"\"\n    self.close()\n</code></pre>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.__getstate__","title":"<code>__getstate__</code>  <code>special</code>","text":"<p>Allows block to be pickled and dumped.</p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>def __getstate__(self):\n    \"\"\"Allows block to be pickled and dumped.\"\"\"\n    data = self.__dict__.copy()\n    data.update({k: None for k in {\"_connection\", \"_unique_cursors\"}})\n    return data\n</code></pre>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.__json_encoder__","title":"<code>__json_encoder__</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.__setstate__","title":"<code>__setstate__</code>  <code>special</code>","text":"<p>Reset connection and cursors upon loading.</p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>def __setstate__(self, data: dict):\n    \"\"\"Reset connection and cursors upon loading.\"\"\"\n    self.__dict__.update(data)\n    self._start_connection()\n</code></pre>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.close","title":"<code>close</code>","text":"<p>Closes connection and its cursors.</p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes connection and its cursors.\n    \"\"\"\n    try:\n        self.reset_cursors()\n    finally:\n        if self._connection is None:\n            self.logger.info(\"There was no connection open to be closed.\")\n            return\n        self._connection.close()\n        self._connection = None\n        self.logger.info(\"Successfully closed the Snowflake connection.\")\n</code></pre>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.execute","title":"<code>execute</code>  <code>async</code>","text":"<p>Executes an operation on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operation upon calling.</p> <p>Parameters:</p>    Name Type Description Default     <code>operation</code> <code>str</code> <p>The SQL query or other operation to be executed.</p> required   <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>The parameters for the operation.</p> <code>None</code>   <code>**execute_kwargs</code> <code>Dict[str, Any]</code> <p>Additional options to pass to <code>cursor.execute_async</code>.</p> <code>{}</code>    <p>Examples:</p> <p>Create table named customers with two columns, name and address. <pre><code>from prefect_snowflake.database import SnowflakeConnector\n\nwith SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\n        \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n    )\n</code></pre></p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>@sync_compatible\nasync def execute(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = None,\n    **execute_kwargs: Dict[str, Any],\n) -&gt; None:\n    \"\"\"\n    Executes an operation on the database. This method is intended to be used\n    for operations that do not return data, such as INSERT, UPDATE, or DELETE.\n    Unlike the fetch methods, this method will always execute the operation\n    upon calling.\n\n    Args:\n        operation: The SQL query or other operation to be executed.\n        parameters: The parameters for the operation.\n        **execute_kwargs: Additional options to pass to `cursor.execute_async`.\n\n    Examples:\n        Create table named customers with two columns, name and address.\n        ```python\n        from prefect_snowflake.database import SnowflakeConnector\n\n        with SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\n                \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n            )\n        ```\n    \"\"\"  # noqa\n    self._start_connection()\n\n    inputs = dict(\n        command=operation,\n        params=parameters,\n        **execute_kwargs,\n    )\n    with self._connection.cursor() as cursor:\n        await run_sync_in_worker_thread(cursor.execute, **inputs)\n    self.logger.info(f\"Executed the operation, {operation!r}.\")\n</code></pre>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.execute_many","title":"<code>execute_many</code>  <code>async</code>","text":"<p>Executes many operations on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operations upon calling.</p> <p>Parameters:</p>    Name Type Description Default     <code>operation</code> <code>str</code> <p>The SQL query or other operation to be executed.</p> required   <code>seq_of_parameters</code> <code>List[Dict[str, Any]]</code> <p>The sequence of parameters for the operation.</p> required    <p>Examples:</p> <p>Create table and insert three rows into it. <pre><code>from prefect_snowflake.database import SnowflakeConnector\n\nwith SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\n        \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n    )\n    conn.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n        seq_of_parameters=[\n            {\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n        ],\n    )\n</code></pre></p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>@sync_compatible\nasync def execute_many(\n    self,\n    operation: str,\n    seq_of_parameters: List[Dict[str, Any]],\n) -&gt; None:\n    \"\"\"\n    Executes many operations on the database. This method is intended to be used\n    for operations that do not return data, such as INSERT, UPDATE, or DELETE.\n    Unlike the fetch methods, this method will always execute the operations\n    upon calling.\n\n    Args:\n        operation: The SQL query or other operation to be executed.\n        seq_of_parameters: The sequence of parameters for the operation.\n\n    Examples:\n        Create table and insert three rows into it.\n        ```python\n        from prefect_snowflake.database import SnowflakeConnector\n\n        with SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\n                \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n            )\n            conn.execute_many(\n                \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n                seq_of_parameters=[\n                    {\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Unknown\", \"address\": \"Space\"},\n                ],\n            )\n        ```\n    \"\"\"  # noqa\n    self._start_connection()\n\n    inputs = dict(\n        command=operation,\n        seqparams=seq_of_parameters,\n    )\n    with self._connection.cursor() as cursor:\n        await run_sync_in_worker_thread(cursor.executemany, **inputs)\n    self.logger.info(\n        f\"Executed {len(seq_of_parameters)} operations off {operation!r}.\"\n    )\n</code></pre>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.fetch_all","title":"<code>fetch_all</code>  <code>async</code>","text":"<p>Fetch all results from the database. Repeated calls using the same inputs to any of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called.</p> <p>Parameters:</p>    Name Type Description Default     <code>operation</code> <code>str</code> <p>The SQL query or other operation to be executed.</p> required   <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>The parameters for the operation.</p> <code>None</code>   <code>**execute_kwargs</code> <code>Dict[str, Any]</code> <p>Additional options to pass to <code>cursor.execute_async</code>.</p> <code>{}</code>    <p>Returns:</p>    Type Description     <code>List[Tuple[Any]]</code> <p>A list of tuples containing the data returned by the database,     where each row is a tuple and each column is a value in the tuple.</p>    <p>Examples:</p> <p>Fetch all rows from the database where address is Highway 42. <pre><code>from prefect_snowflake.database import SnowflakeConnector\n\nwith SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\n        \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n    )\n    conn.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n        seq_of_parameters=[\n            {\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Highway 42\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n    result = conn.fetch_all(\n        \"SELECT * FROM customers WHERE address = %(address)s\",\n        parameters={\"address\": \"Highway 42\"},\n    )\n    print(result)  # Marvin, Ford, Unknown\n</code></pre></p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>@sync_compatible\nasync def fetch_all(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = None,\n    **execute_kwargs: Dict[str, Any],\n) -&gt; List[Tuple[Any]]:\n    \"\"\"\n    Fetch all results from the database.\n    Repeated calls using the same inputs to *any* of the fetch methods of this\n    block will skip executing the operation again, and instead,\n    return the next set of results from the previous execution,\n    until the reset_cursors method is called.\n\n    Args:\n        operation: The SQL query or other operation to be executed.\n        parameters: The parameters for the operation.\n        **execute_kwargs: Additional options to pass to `cursor.execute_async`.\n\n    Returns:\n        A list of tuples containing the data returned by the database,\n            where each row is a tuple and each column is a value in the tuple.\n\n    Examples:\n        Fetch all rows from the database where address is Highway 42.\n        ```python\n        from prefect_snowflake.database import SnowflakeConnector\n\n        with SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\n                \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n            )\n            conn.execute_many(\n                \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n                seq_of_parameters=[\n                    {\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Unknown\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                ],\n            )\n            result = conn.fetch_all(\n                \"SELECT * FROM customers WHERE address = %(address)s\",\n                parameters={\"address\": \"Highway 42\"},\n            )\n            print(result)  # Marvin, Ford, Unknown\n        ```\n    \"\"\"  # noqa\n    inputs = dict(\n        command=operation,\n        params=parameters,\n        **execute_kwargs,\n    )\n    new, cursor = self._get_cursor(inputs)\n    if new:\n        await self._execute_async(cursor, inputs)\n    self.logger.debug(\"Preparing to fetch all rows.\")\n    result = await run_sync_in_worker_thread(cursor.fetchall)\n    return result\n</code></pre>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.fetch_many","title":"<code>fetch_many</code>  <code>async</code>","text":"<p>Fetch a limited number of results from the database. Repeated calls using the same inputs to any of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called.</p> <p>Parameters:</p>    Name Type Description Default     <code>operation</code> <code>str</code> <p>The SQL query or other operation to be executed.</p> required   <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>The parameters for the operation.</p> <code>None</code>   <code>size</code> <code>Optional[int]</code> <p>The number of results to return; if None or 0, uses the value of <code>fetch_size</code> configured on the block.</p> <code>None</code>   <code>**execute_kwargs</code> <code>Dict[str, Any]</code> <p>Additional options to pass to <code>cursor.execute_async</code>.</p> <code>{}</code>    <p>Returns:</p>    Type Description     <code>List[Tuple[Any]]</code> <p>A list of tuples containing the data returned by the database,     where each row is a tuple and each column is a value in the tuple.</p>    <p>Examples:</p> <p>Repeatedly fetch two rows from the database where address is Highway 42. <pre><code>from prefect_snowflake.database import SnowflakeConnector\n\nwith SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\n        \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n    )\n    conn.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n        seq_of_parameters=[\n            {\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Highway 42\"},\n            {\"name\": \"Me\", \"address\": \"Highway 42\"},\n        ],\n    )\n    result = conn.fetch_many(\n        \"SELECT * FROM customers WHERE address = %(address)s\",\n        parameters={\"address\": \"Highway 42\"},\n        size=2\n    )\n    print(result)  # Marvin, Ford\n    result = conn.fetch_many(\n        \"SELECT * FROM customers WHERE address = %(address)s\",\n        parameters={\"address\": \"Highway 42\"},\n        size=2\n    )\n    print(result)  # Unknown, Me\n</code></pre></p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>@sync_compatible\nasync def fetch_many(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = None,\n    size: Optional[int] = None,\n    **execute_kwargs: Dict[str, Any],\n) -&gt; List[Tuple[Any]]:\n    \"\"\"\n    Fetch a limited number of results from the database.\n    Repeated calls using the same inputs to *any* of the fetch methods of this\n    block will skip executing the operation again, and instead,\n    return the next set of results from the previous execution,\n    until the reset_cursors method is called.\n\n    Args:\n        operation: The SQL query or other operation to be executed.\n        parameters: The parameters for the operation.\n        size: The number of results to return; if None or 0, uses the value of\n            `fetch_size` configured on the block.\n        **execute_kwargs: Additional options to pass to `cursor.execute_async`.\n\n    Returns:\n        A list of tuples containing the data returned by the database,\n            where each row is a tuple and each column is a value in the tuple.\n\n    Examples:\n        Repeatedly fetch two rows from the database where address is Highway 42.\n        ```python\n        from prefect_snowflake.database import SnowflakeConnector\n\n        with SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\n                \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n            )\n            conn.execute_many(\n                \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n                seq_of_parameters=[\n                    {\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Unknown\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Me\", \"address\": \"Highway 42\"},\n                ],\n            )\n            result = conn.fetch_many(\n                \"SELECT * FROM customers WHERE address = %(address)s\",\n                parameters={\"address\": \"Highway 42\"},\n                size=2\n            )\n            print(result)  # Marvin, Ford\n            result = conn.fetch_many(\n                \"SELECT * FROM customers WHERE address = %(address)s\",\n                parameters={\"address\": \"Highway 42\"},\n                size=2\n            )\n            print(result)  # Unknown, Me\n        ```\n    \"\"\"  # noqa\n    inputs = dict(\n        command=operation,\n        params=parameters,\n        **execute_kwargs,\n    )\n    new, cursor = self._get_cursor(inputs)\n    if new:\n        await self._execute_async(cursor, inputs)\n    size = size or self.fetch_size\n    self.logger.debug(f\"Preparing to fetch {size} rows.\")\n    result = await run_sync_in_worker_thread(cursor.fetchmany, size=size)\n    return result\n</code></pre>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.fetch_one","title":"<code>fetch_one</code>  <code>async</code>","text":"<p>Fetch a single result from the database. Repeated calls using the same inputs to any of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called.</p> <p>Parameters:</p>    Name Type Description Default     <code>operation</code> <code>str</code> <p>The SQL query or other operation to be executed.</p> required   <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>The parameters for the operation.</p> <code>None</code>   <code>**execute_kwargs</code> <code>Dict[str, Any]</code> <p>Additional options to pass to <code>cursor.execute_async</code>.</p> <code>{}</code>    <p>Returns:</p>    Type Description     <code>Tuple[Any]</code> <p>A tuple containing the data returned by the database,     where each row is a tuple and each column is a value in the tuple.</p>    <p>Examples:</p> <p>Fetch one row from the database where address is Space. <pre><code>from prefect_snowflake.database import SnowflakeConnector\n\nwith SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\n        \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n    )\n    conn.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n        seq_of_parameters=[\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n    result = conn.fetch_one(\n        \"SELECT * FROM customers WHERE address = %(address)s\",\n        parameters={\"address\": \"Space\"}\n    )\n    print(result)\n</code></pre></p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>@sync_compatible\nasync def fetch_one(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = None,\n    **execute_kwargs: Dict[str, Any],\n) -&gt; Tuple[Any]:\n    \"\"\"\n    Fetch a single result from the database.\n    Repeated calls using the same inputs to *any* of the fetch methods of this\n    block will skip executing the operation again, and instead,\n    return the next set of results from the previous execution,\n    until the reset_cursors method is called.\n\n    Args:\n        operation: The SQL query or other operation to be executed.\n        parameters: The parameters for the operation.\n        **execute_kwargs: Additional options to pass to `cursor.execute_async`.\n\n    Returns:\n        A tuple containing the data returned by the database,\n            where each row is a tuple and each column is a value in the tuple.\n\n    Examples:\n        Fetch one row from the database where address is Space.\n        ```python\n        from prefect_snowflake.database import SnowflakeConnector\n\n        with SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\n                \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n            )\n            conn.execute_many(\n                \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n                seq_of_parameters=[\n                    {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Unknown\", \"address\": \"Space\"},\n                    {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                ],\n            )\n            result = conn.fetch_one(\n                \"SELECT * FROM customers WHERE address = %(address)s\",\n                parameters={\"address\": \"Space\"}\n            )\n            print(result)\n        ```\n    \"\"\"  # noqa\n    inputs = dict(\n        command=operation,\n        params=parameters,\n        **execute_kwargs,\n    )\n    new, cursor = self._get_cursor(inputs)\n    if new:\n        await self._execute_async(cursor, inputs)\n    self.logger.debug(\"Preparing to fetch a row.\")\n    result = await run_sync_in_worker_thread(cursor.fetchone)\n    return result\n</code></pre>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.get_connection","title":"<code>get_connection</code>","text":"<p>Returns an authenticated connection that can be used to query from Snowflake databases.</p> <p>Parameters:</p>    Name Type Description Default     <code>**connect_kwargs</code> <code>Dict[str, Any]</code> <p>Additional arguments to pass to <code>snowflake.connector.connect</code>.</p> <code>{}</code>    <p>Returns:</p>    Type Description     <code>SnowflakeConnection</code> <p>The authenticated SnowflakeConnection.</p>    <p>Examples:</p> <pre><code>from prefect_snowflake.credentials import SnowflakeCredentials\nfrom prefect_snowflake.database import SnowflakeConnector\n\nsnowflake_credentials = SnowflakeCredentials(\n    account=\"account\",\n    user=\"user\",\n    password=\"password\",\n)\nsnowflake_connector = SnowflakeConnector(\n    database=\"database\",\n    warehouse=\"warehouse\",\n    schema=\"schema\",\n    credentials=snowflake_credentials\n)\nwith snowflake_connector.get_connection() as connection:\n    ...\n</code></pre>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>def get_connection(self, **connect_kwargs: Dict[str, Any]) -&gt; SnowflakeConnection:\n    \"\"\"\n    Returns an authenticated connection that can be\n    used to query from Snowflake databases.\n\n    Args:\n        **connect_kwargs: Additional arguments to pass to\n            `snowflake.connector.connect`.\n\n    Returns:\n        The authenticated SnowflakeConnection.\n\n    Examples:\n        ```python\n        from prefect_snowflake.credentials import SnowflakeCredentials\n        from prefect_snowflake.database import SnowflakeConnector\n\n        snowflake_credentials = SnowflakeCredentials(\n            account=\"account\",\n            user=\"user\",\n            password=\"password\",\n        )\n        snowflake_connector = SnowflakeConnector(\n            database=\"database\",\n            warehouse=\"warehouse\",\n            schema=\"schema\",\n            credentials=snowflake_credentials\n        )\n        with snowflake_connector.get_connection() as connection:\n            ...\n        ```\n    \"\"\"\n    if self._connection is not None:\n        return self._connection\n\n    connect_params = {\n        \"database\": self.database,\n        \"warehouse\": self.warehouse,\n        \"schema\": self.schema_,\n    }\n    connection = self.credentials.get_client(**connect_kwargs, **connect_params)\n    self._connection = connection\n    self.logger.info(\"Started a new connection to Snowflake.\")\n    return connection\n</code></pre>"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.reset_cursors","title":"<code>reset_cursors</code>","text":"<p>Tries to close all opened cursors.</p> <p>Examples:</p> <p>Reset the cursors to refresh cursor position. <pre><code>from prefect_snowflake.database import SnowflakeConnector\n\nwith SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\n        \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n    )\n    conn.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n        seq_of_parameters=[\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n    print(conn.fetch_one(\"SELECT * FROM customers\"))  # Ford\n    conn.reset_cursors()\n    print(conn.fetch_one(\"SELECT * FROM customers\"))  # should be Ford again\n</code></pre></p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>def reset_cursors(self) -&gt; None:\n    \"\"\"\n    Tries to close all opened cursors.\n\n    Examples:\n        Reset the cursors to refresh cursor position.\n        ```python\n        from prefect_snowflake.database import SnowflakeConnector\n\n        with SnowflakeConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\n                \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n            )\n            conn.execute_many(\n                \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n                seq_of_parameters=[\n                    {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Unknown\", \"address\": \"Space\"},\n                    {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                ],\n            )\n            print(conn.fetch_one(\"SELECT * FROM customers\"))  # Ford\n            conn.reset_cursors()\n            print(conn.fetch_one(\"SELECT * FROM customers\"))  # should be Ford again\n        ```\n    \"\"\"  # noqa\n    if not self._unique_cursors:\n        self.logger.info(\"There were no cursors to reset.\")\n        return\n\n    input_hashes = tuple(self._unique_cursors.keys())\n    for input_hash in input_hashes:\n        cursor = self._unique_cursors.pop(input_hash)\n        try:\n            cursor.close()\n        except Exception as exc:\n            self.logger.warning(\n                f\"Failed to close cursor for input hash {input_hash!r}: {exc}\"\n            )\n    self.logger.info(\"Successfully reset the cursors.\")\n</code></pre>"},{"location":"database/#prefect_snowflake.database-functions","title":"Functions","text":""},{"location":"database/#prefect_snowflake.database.snowflake_multiquery","title":"<code>snowflake_multiquery</code>  <code>async</code>","text":"<p>Executes multiple queries against a Snowflake database in a shared session. Allows execution in a transaction.</p> <p>Parameters:</p>    Name Type Description Default     <code>queries</code> <code>List[str]</code> <p>The list of queries to execute against the database.</p> required   <code>params</code> <code>Union[Tuple[Any], Dict[str, Any]]</code> <p>The params to replace the placeholders in the query.</p> <code>None</code>   <code>snowflake_connector</code> <code>SnowflakeConnector</code> <p>The credentials to use to authenticate.</p> required   <code>cursor_type</code> <code>SnowflakeCursor</code> <p>The type of database cursor to use for the query.</p> <code>&lt;class 'snowflake.connector.cursor.SnowflakeCursor'&gt;</code>   <code>as_transaction</code> <code>bool</code> <p>If True, queries are executed in a transaction.</p> <code>False</code>   <code>return_transaction_control_results</code> <code>bool</code> <p>Determines if the results of queries controlling the transaction (BEGIN/COMMIT) should be returned.</p> <code>False</code>   <code>poll_frequency_seconds</code> <code>int</code> <p>Number of seconds to wait in between checks for run completion.</p> <code>1</code>    <p>Returns:</p>    Type Description     <code>List[List[Tuple[Any]]]</code> <p>List of the outputs of <code>response.fetchall()</code> for each query.</p>    <p>Examples:</p> <p>Query Snowflake table with the ID value parameterized. <pre><code>from prefect import flow\nfrom prefect_snowflake.credentials import SnowflakeCredentials\nfrom prefect_snowflake.database import SnowflakeConnector, snowflake_multiquery\n\n\n@flow\ndef snowflake_multiquery_flow():\n    snowflake_credentials = SnowflakeCredentials(\n        account=\"account\",\n        user=\"user\",\n        password=\"password\",\n    )\n    snowflake_connector = SnowflakeConnector(\n        database=\"database\",\n        warehouse=\"warehouse\",\n        schema=\"schema\",\n        credentials=snowflake_credentials\n    )\n    result = snowflake_multiquery(\n        [\"SELECT * FROM table WHERE id=%{id_param}s LIMIT 8;\", \"SELECT 1,2\"],\n        snowflake_connector,\n        params={\"id_param\": 1},\n        as_transaction=True\n    )\n    return result\n\nsnowflake_multiquery_flow()\n</code></pre></p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>@task\nasync def snowflake_multiquery(\n    queries: List[str],\n    snowflake_connector: SnowflakeConnector,\n    params: Union[Tuple[Any], Dict[str, Any]] = None,\n    cursor_type: SnowflakeCursor = SnowflakeCursor,\n    as_transaction: bool = False,\n    return_transaction_control_results: bool = False,\n    poll_frequency_seconds: int = 1,\n) -&gt; List[List[Tuple[Any]]]:\n    \"\"\"\n    Executes multiple queries against a Snowflake database in a shared session.\n    Allows execution in a transaction.\n\n    Args:\n        queries: The list of queries to execute against the database.\n        params: The params to replace the placeholders in the query.\n        snowflake_connector: The credentials to use to authenticate.\n        cursor_type: The type of database cursor to use for the query.\n        as_transaction: If True, queries are executed in a transaction.\n        return_transaction_control_results: Determines if the results of queries\n            controlling the transaction (BEGIN/COMMIT) should be returned.\n        poll_frequency_seconds: Number of seconds to wait in between checks for\n            run completion.\n\n    Returns:\n        List of the outputs of `response.fetchall()` for each query.\n\n    Examples:\n        Query Snowflake table with the ID value parameterized.\n        ```python\n        from prefect import flow\n        from prefect_snowflake.credentials import SnowflakeCredentials\n        from prefect_snowflake.database import SnowflakeConnector, snowflake_multiquery\n\n\n        @flow\n        def snowflake_multiquery_flow():\n            snowflake_credentials = SnowflakeCredentials(\n                account=\"account\",\n                user=\"user\",\n                password=\"password\",\n            )\n            snowflake_connector = SnowflakeConnector(\n                database=\"database\",\n                warehouse=\"warehouse\",\n                schema=\"schema\",\n                credentials=snowflake_credentials\n            )\n            result = snowflake_multiquery(\n                [\"SELECT * FROM table WHERE id=%{id_param}s LIMIT 8;\", \"SELECT 1,2\"],\n                snowflake_connector,\n                params={\"id_param\": 1},\n                as_transaction=True\n            )\n            return result\n\n        snowflake_multiquery_flow()\n        ```\n    \"\"\"\n    with snowflake_connector.get_connection() as connection:\n        if as_transaction:\n            queries.insert(0, BEGIN_TRANSACTION_STATEMENT)\n            queries.append(END_TRANSACTION_STATEMENT)\n\n        with connection.cursor(cursor_type) as cursor:\n            results = []\n            for query in queries:\n                response = cursor.execute_async(query, params=params)\n                query_id = response[\"queryId\"]\n                while connection.is_still_running(\n                    connection.get_query_status_throw_if_error(query_id)\n                ):\n                    await asyncio.sleep(poll_frequency_seconds)\n                cursor.get_results_from_sfqid(query_id)\n                result = cursor.fetchall()\n                results.append(result)\n\n    # cut off results from BEGIN/COMMIT queries\n    if as_transaction and not return_transaction_control_results:\n        return results[1:-1]\n    else:\n        return results\n</code></pre>"},{"location":"database/#prefect_snowflake.database.snowflake_query","title":"<code>snowflake_query</code>  <code>async</code>","text":"<p>Executes a query against a Snowflake database.</p> <p>Parameters:</p>    Name Type Description Default     <code>query</code> <code>str</code> <p>The query to execute against the database.</p> required   <code>params</code> <code>Union[Tuple[Any], Dict[str, Any]]</code> <p>The params to replace the placeholders in the query.</p> <code>None</code>   <code>snowflake_connector</code> <code>SnowflakeConnector</code> <p>The credentials to use to authenticate.</p> required   <code>cursor_type</code> <code>SnowflakeCursor</code> <p>The type of database cursor to use for the query.</p> <code>&lt;class 'snowflake.connector.cursor.SnowflakeCursor'&gt;</code>   <code>poll_frequency_seconds</code> <code>int</code> <p>Number of seconds to wait in between checks for run completion.</p> <code>1</code>    <p>Returns:</p>    Type Description     <code>List[Tuple[Any]]</code> <p>The output of <code>response.fetchall()</code>.</p>    <p>Examples:</p> <p>Query Snowflake table with the ID value parameterized. <pre><code>from prefect import flow\nfrom prefect_snowflake.credentials import SnowflakeCredentials\nfrom prefect_snowflake.database import SnowflakeConnector, snowflake_query\n\n\n@flow\ndef snowflake_query_flow():\n    snowflake_credentials = SnowflakeCredentials(\n        account=\"account\",\n        user=\"user\",\n        password=\"password\",\n    )\n    snowflake_connector = SnowflakeConnector(\n        database=\"database\",\n        warehouse=\"warehouse\",\n        schema=\"schema\",\n        credentials=snowflake_credentials\n    )\n    result = snowflake_query(\n        \"SELECT * FROM table WHERE id=%{id_param}s LIMIT 8;\",\n        snowflake_connector,\n        params={\"id_param\": 1}\n    )\n    return result\n\nsnowflake_query_flow()\n</code></pre></p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>@task\nasync def snowflake_query(\n    query: str,\n    snowflake_connector: SnowflakeConnector,\n    params: Union[Tuple[Any], Dict[str, Any]] = None,\n    cursor_type: SnowflakeCursor = SnowflakeCursor,\n    poll_frequency_seconds: int = 1,\n) -&gt; List[Tuple[Any]]:\n    \"\"\"\n    Executes a query against a Snowflake database.\n\n    Args:\n        query: The query to execute against the database.\n        params: The params to replace the placeholders in the query.\n        snowflake_connector: The credentials to use to authenticate.\n        cursor_type: The type of database cursor to use for the query.\n        poll_frequency_seconds: Number of seconds to wait in between checks for\n            run completion.\n\n    Returns:\n        The output of `response.fetchall()`.\n\n    Examples:\n        Query Snowflake table with the ID value parameterized.\n        ```python\n        from prefect import flow\n        from prefect_snowflake.credentials import SnowflakeCredentials\n        from prefect_snowflake.database import SnowflakeConnector, snowflake_query\n\n\n        @flow\n        def snowflake_query_flow():\n            snowflake_credentials = SnowflakeCredentials(\n                account=\"account\",\n                user=\"user\",\n                password=\"password\",\n            )\n            snowflake_connector = SnowflakeConnector(\n                database=\"database\",\n                warehouse=\"warehouse\",\n                schema=\"schema\",\n                credentials=snowflake_credentials\n            )\n            result = snowflake_query(\n                \"SELECT * FROM table WHERE id=%{id_param}s LIMIT 8;\",\n                snowflake_connector,\n                params={\"id_param\": 1}\n            )\n            return result\n\n        snowflake_query_flow()\n        ```\n    \"\"\"\n    # context manager automatically rolls back failed transactions and closes\n    with snowflake_connector.get_connection() as connection:\n        with connection.cursor(cursor_type) as cursor:\n            response = cursor.execute_async(query, params=params)\n            query_id = response[\"queryId\"]\n            while connection.is_still_running(\n                connection.get_query_status_throw_if_error(query_id)\n            ):\n                await asyncio.sleep(poll_frequency_seconds)\n            cursor.get_results_from_sfqid(query_id)\n            result = cursor.fetchall()\n    return result\n</code></pre>"},{"location":"database/#prefect_snowflake.database.snowflake_query_sync","title":"<code>snowflake_query_sync</code>  <code>async</code>","text":"<p>Executes a query in sync mode against a Snowflake database.</p> <p>Parameters:</p>    Name Type Description Default     <code>query</code> <code>str</code> <p>The query to execute against the database.</p> required   <code>params</code> <code>Union[Tuple[Any], Dict[str, Any]]</code> <p>The params to replace the placeholders in the query.</p> <code>None</code>   <code>snowflake_connector</code> <code>SnowflakeConnector</code> <p>The credentials to use to authenticate.</p> required   <code>cursor_type</code> <code>SnowflakeCursor</code> <p>The type of database cursor to use for the query.</p> <code>&lt;class 'snowflake.connector.cursor.SnowflakeCursor'&gt;</code>    <p>Returns:</p>    Type Description     <code>List[Tuple[Any]]</code> <p>The output of <code>response.fetchall()</code>.</p>    <p>Examples:</p> <p>Execute a put statement. <pre><code>from prefect import flow\nfrom prefect_snowflake.credentials import SnowflakeCredentials\nfrom prefect_snowflake.database import SnowflakeConnector, snowflake_query\n\n\n@flow\ndef snowflake_query_sync_flow():\n    snowflake_credentials = SnowflakeCredentials(\n        account=\"account\",\n        user=\"user\",\n        password=\"password\",\n    )\n    snowflake_connector = SnowflakeConnector(\n        database=\"database\",\n        warehouse=\"warehouse\",\n        schema=\"schema\",\n        credentials=snowflake_credentials\n    )\n    result = snowflake_query_sync(\n        \"put file://afile.csv @mystage;\",\n        snowflake_connector,\n    )\n    return result\n\nsnowflake_query_sync_flow()\n</code></pre></p>  Source code in <code>prefect_snowflake/database.py</code> <pre><code>@task\nasync def snowflake_query_sync(\n    query: str,\n    snowflake_connector: SnowflakeConnector,\n    params: Union[Tuple[Any], Dict[str, Any]] = None,\n    cursor_type: SnowflakeCursor = SnowflakeCursor,\n) -&gt; List[Tuple[Any]]:\n    \"\"\"\n    Executes a query in sync mode against a Snowflake database.\n\n    Args:\n        query: The query to execute against the database.\n        params: The params to replace the placeholders in the query.\n        snowflake_connector: The credentials to use to authenticate.\n        cursor_type: The type of database cursor to use for the query.\n\n    Returns:\n        The output of `response.fetchall()`.\n\n    Examples:\n        Execute a put statement.\n        ```python\n        from prefect import flow\n        from prefect_snowflake.credentials import SnowflakeCredentials\n        from prefect_snowflake.database import SnowflakeConnector, snowflake_query\n\n\n        @flow\n        def snowflake_query_sync_flow():\n            snowflake_credentials = SnowflakeCredentials(\n                account=\"account\",\n                user=\"user\",\n                password=\"password\",\n            )\n            snowflake_connector = SnowflakeConnector(\n                database=\"database\",\n                warehouse=\"warehouse\",\n                schema=\"schema\",\n                credentials=snowflake_credentials\n            )\n            result = snowflake_query_sync(\n                \"put file://afile.csv @mystage;\",\n                snowflake_connector,\n            )\n            return result\n\n        snowflake_query_sync_flow()\n        ```\n    \"\"\"\n    # context manager automatically rolls back failed transactions and closes\n    with snowflake_connector.get_connection() as connection:\n        with connection.cursor(cursor_type) as cursor:\n            cursor.execute(query, params=params)\n            result = cursor.fetchall()\n    return result\n</code></pre>"}]}